package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
)

var (
	reCountryLine = regexp.MustCompile(`\|([^|]+)\|https?://[^\s|]*/data/country/([A-Z]{2})\.txt\|?`)
	reCNLine      = regexp.MustCompile(`\|([^|]+)\|https?://[^\s|]*/data/cncity/(\d{6})\.txt\|?`)
)

func main() {
	var (
		countryPath = flag.String("country", "docs/country.md", "path to docs/country.md")
		cncityPath  = flag.String("cncity", "docs/cncity.md", "path to docs/cncity.md")
		outPath     = flag.String("out", "docs_names_gen.go", "output Go file (package iplist)")
	)
	flag.Parse()

	countryNames, err := parseNames(*countryPath, reCountryLine)
	if err != nil {
		die(err)
	}
	cnNames, err := parseNames(*cncityPath, reCNLine)
	if err != nil {
		die(err)
	}

	outAbs, err := filepath.Abs(*outPath)
	if err != nil {
		die(err)
	}

	src := render(countryNames, cnNames)
	fmted, err := format.Source(src)
	if err != nil {
		_ = os.WriteFile(outAbs, src, 0o644)
		die(fmt.Errorf("gofmt %s: %w", outAbs, err))
	}

	if err := os.WriteFile(outAbs, fmted, 0o644); err != nil {
		die(err)
	}
}

func die(err error) {
	_, _ = fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}

func parseNames(path string, re *regexp.Regexp) (map[string]string, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	m := make(map[string]string)
	s := bufio.NewScanner(f)
	for s.Scan() {
		line := s.Text()
		g := re.FindStringSubmatch(line)
		if len(g) == 3 {
			name := g[1]
			code := g[2]
			m[code] = name
		}
	}
	if err := s.Err(); err != nil {
		return nil, err
	}
	return m, nil
}

func render(country map[string]string, cn map[string]string) []byte {
	countryKeys := make([]string, 0, len(country))
	for k := range country {
		countryKeys = append(countryKeys, k)
	}
	sort.Strings(countryKeys)

	cnKeys := make([]string, 0, len(cn))
	for k := range cn {
		cnKeys = append(cnKeys, k)
	}
	sort.Strings(cnKeys)

	b := &bytes.Buffer{}
	fmt.Fprintln(b, "// Code generated by internal/cmd/gen-names; DO NOT EDIT.")
	fmt.Fprintln(b)
	fmt.Fprintln(b, "package iplist")
	fmt.Fprintln(b)
	fmt.Fprintln(b, "func init() {")
	writeTable(b, "docsCountry", countryKeys, country, 2)
	writeTable(b, "docsCNCity", cnKeys, cn, 6)
	fmt.Fprintln(b, "}")
	return b.Bytes()
}

func writeTable(w io.Writer, prefix string, keys []string, m map[string]string, keyLen int) {
	keyBlob := &bytes.Buffer{}
	valBlob := &bytes.Buffer{}
	off := make([]uint32, 0, len(keys)+1)
	off = append(off, 0)

	for _, k := range keys {
		if len(k) != keyLen {
			// Skip unexpected keys (should not happen for current inputs).
			continue
		}
		_, _ = keyBlob.WriteString(k)
		v := m[k]
		_, _ = valBlob.WriteString(v)
		off = append(off, uint32(valBlob.Len()))
	}

	keysLit := strconv.Quote(keyBlob.String())
	valsLit := strconv.Quote(valBlob.String())

	fmt.Fprintf(w, "\t%sKeys = %s\n", prefix, keysLit)
	fmt.Fprintf(w, "\t%sVals = %s\n", prefix, valsLit)
	fmt.Fprintf(w, "\t%sOff = []uint32{", prefix)
	for i, v := range off {
		if i > 0 {
			_, _ = io.WriteString(w, ",")
		}
		fmt.Fprintf(w, "%d", v)
	}
	_, _ = io.WriteString(w, "}\n")
}
